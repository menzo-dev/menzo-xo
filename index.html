<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MENZO-XO: ULTIMATE SINGULARITY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        :root {
            /* Dark Theme (Default) */
            --bg-primary: #030308;
            --bg-secondary: rgba(12, 18, 35, 0.92);
            --bg-tertiary: rgba(20, 28, 50, 0.85);
            --text-primary: #ffffff;
            --text-secondary: #a8b3cf;
            --text-dim: #6b7a99;
            
            --accent-cyan: #00f5ff;
            --accent-pink: #d446ff;
            --accent-gold: #ffd700;
            --accent-green: #00ff9d;
            --accent-red: #ff4d7a;
            
            --glow-cyan: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(0, 245, 255, 0.3);
            --glow-pink: 0 0 20px rgba(212, 70, 255, 0.5), 0 0 40px rgba(212, 70, 255, 0.3);
            --glow-gold: 0 0 20px rgba(255, 215, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);
            
            --border-glass: 1px solid rgba(255, 255, 255, 0.12);
            --shadow-deep: 0 10px 40px rgba(0, 0, 0, 0.6);
            --shadow-glow: 0 0 60px rgba(0, 245, 255, 0.15);
            
            --transition-smooth: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: rgba(248, 250, 252, 0.95);
            --bg-tertiary: rgba(255, 255, 255, 0.9);
            --text-primary: #1a1f36;
            --text-secondary: #4a5568;
            --text-dim: #718096;
            
            --accent-cyan: #00a8cc;
            --accent-pink: #9b2eee;
            --accent-gold: #d4a017;
            --accent-green: #00b374;
            --accent-red: #e63946;
            
            --glow-cyan: 0 0 15px rgba(0, 168, 204, 0.4);
            --glow-pink: 0 0 15px rgba(155, 46, 238, 0.4);
            --glow-gold: 0 0 15px rgba(212, 160, 23, 0.4);
            
            --border-glass: 1px solid rgba(0, 0, 0, 0.08);
            --shadow-deep: 0 10px 40px rgba(0, 0, 0, 0.12);
            --shadow-glow: 0 0 40px rgba(0, 168, 204, 0.12);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            transition: var(--transition-smooth);
            background-image: 
                radial-gradient(ellipse at 15% 85%, rgba(212, 70, 255, 0.06) 0%, transparent 45%),
                radial-gradient(ellipse at 85% 15%, rgba(0, 245, 255, 0.06) 0%, transparent 45%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 215, 0, 0.03) 0%, transparent 60%);
        }

        /* === FLOATING TOGGLE BUTTON === */
        .sidebar-toggle {
            position: fixed;
            top: 25px;
            right: 25px;
            width: 54px;
            height: 54px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink));
            border: none;
            border-radius: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            color: #000;
            box-shadow: var(--glow-cyan);
            z-index: 1000;
            transition: var(--transition-bounce);
            animation: floatBtn 4s ease-in-out infinite;
        }
        .sidebar-toggle:hover {
            transform: scale(1.12) rotate(3deg);
            box-shadow: 0 0 35px rgba(0, 245, 255, 0.7), 0 0 60px rgba(212, 70, 255, 0.5);
        }
        @keyframes floatBtn {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        /* === THEME TOGGLE === */
        .theme-toggle {
            position: fixed;
            top: 25px;
            right: 90px;
            width: 54px;
            height: 54px;
            background: var(--bg-tertiary);
            border: var(--border-glass);
            border-radius: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            color: var(--text-primary);
            box-shadow: var(--shadow-deep);
            z-index: 1000;
            transition: var(--transition-bounce);
        }
        .theme-toggle:hover {
            transform: scale(1.1) rotate(10deg);
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-cyan));
            color: #000;
        }

        /* === SIDEBAR === */
        .sidebar {
            width: 440px;
            background: var(--bg-secondary);
            border-left: var(--border-glass);
            display: flex;
            flex-direction: column;
            padding: 0;
            transition: var(--transition-smooth);
            z-index: 500;
            position: relative;
            box-shadow: var(--shadow-deep);
            backdrop-filter: blur(20px);
        }
        .sidebar.hidden { transform: translateX(100%); }

        .sidebar-header {
            padding: 28px 32px;
            border-bottom: var(--border-glass);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
        }
        .logo {
            font-family: 'Orbitron';
            font-size: 1.7rem;
            font-weight: 900;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-pink), var(--accent-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% auto;
            animation: gradientShift 3s linear infinite;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .sidebar-close {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.6rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 10px;
            transition: 0.2s;
        }
        .sidebar-close:hover { background: rgba(255,255,255,0.1); }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 32px;
        }
        .sidebar-content::-webkit-scrollbar { width: 5px; }
        .sidebar-content::-webkit-scrollbar-thumb { 
            background: linear-gradient(var(--accent-cyan), var(--accent-pink)); 
            border-radius: 5px; 
        }

        .section { margin-bottom: 32px; }
        .section-title {
            font-family: 'Orbitron';
            color: var(--accent-cyan);
            font-size: 1.05rem;
            margin: 24px 0 18px;
            display: flex;
            align-items: center;
            gap: 12px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 700;
        }
        .section-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(var(--accent-cyan), var(--accent-pink));
            border-radius: 2px;
            box-shadow: 0 0 12px var(--accent-cyan);
        }

        /* Level Buttons */
        .level-grid { display: grid; gap: 12px; }
        .level-btn {
            width: 100%;
            padding: 16px 22px;
            background: var(--bg-tertiary);
            border: var(--border-glass);
            color: var(--text-secondary);
            font-family: 'Rajdhani';
            font-weight: 700;
            font-size: 1.15rem;
            text-align: right;
            cursor: pointer;
            border-radius: 14px;
            transition: var(--transition-bounce);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .level-btn::before {
            content: '';
            position: absolute;
            left: 0; top: 0; height: 100%;
            width: 4px;
            background: transparent;
            transition: 0.3s;
        }
        .level-btn:hover {
            background: rgba(0, 245, 255, 0.12);
            color: var(--accent-cyan);
            border-color: var(--accent-cyan);
            padding-right: 30px;
            transform: translateX(4px);
        }
        .level-btn:hover::before { 
            background: linear-gradient(var(--accent-cyan), var(--accent-pink)); 
            box-shadow: 0 0 15px var(--accent-cyan);
        }
        .level-btn.active {
            background: linear-gradient(135deg, rgba(0,245,255,0.18), rgba(212,70,255,0.12));
            color: var(--text-primary);
            border: 2px solid var(--accent-cyan);
            box-shadow: var(--glow-cyan);
            font-weight: 800;
        }
        .level-btn.active::before { 
            background: linear-gradient(var(--accent-cyan), var(--accent-pink)); 
            box-shadow: 0 0 20px var(--accent-cyan);
        }
        .level-btn.ultimate {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(255, 215, 0, 0.08);
        }
        .level-btn.ultimate:hover,
        .level-btn.ultimate.active {
            border-color: var(--accent-gold);
            color: var(--text-primary);
            background: linear-gradient(135deg, rgba(255,215,0,0.22), rgba(0,245,255,0.15));
            box-shadow: var(--glow-gold);
        }
        .level-btn.ultimate::before { background: linear-gradient(var(--accent-gold), var(--accent-cyan)); }

        /* Cloud Learning Panel */
        .cloud-panel {
            background: linear-gradient(135deg, var(--bg-tertiary), rgba(30, 40, 70, 0.6));
            border: 1px solid var(--accent-green);
            border-radius: 16px;
            padding: 20px;
            margin-top: 8px;
            box-shadow: 0 0 25px rgba(0, 255, 157, 0.15);
        }
        .cloud-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 18px;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .cloud-dot {
            width: 11px; height: 11px;
            background: var(--accent-green);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--accent-green);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%,100% { opacity:1; transform:scale(1); } 50% { opacity:0.6; transform:scale(0.9); } }
        
        .cloud-stat {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }
        .cloud-stat span:last-child {
            color: var(--text-primary);
            font-family: 'Orbitron';
            font-weight: 700;
        }
        .upload-bar {
            height: 5px;
            background: rgba(255,255,255,0.12);
            border-radius: 3px;
            margin-top: 14px;
            overflow: hidden;
            display: none;
        }
        .upload-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-pink), var(--accent-gold));
            transition: width 0.35s ease;
            box-shadow: 0 0 15px var(--accent-cyan);
            border-radius: 3px;
        }

        /* Dev Profile */
        .dev-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: var(--border-glass);
            border-radius: 18px;
            padding: 24px;
            text-align: center;
            box-shadow: var(--shadow-deep);
        }
        .dev-avatar {
            width: 82px; height: 82px;
            margin: 0 auto 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink), var(--accent-gold));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            font-weight: 900;
            color: #000;
            font-family: 'Orbitron';
            box-shadow: var(--glow-cyan);
            animation: floatAvatar 5s ease-in-out infinite;
            position: relative;
        }
        .dev-avatar::after {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-pink), var(--accent-gold), var(--accent-cyan));
            animation: rotateGlow 3s linear infinite;
            z-index: -1;
            opacity: 0.6;
        }
        @keyframes floatAvatar { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes rotateGlow { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .dev-name {
            font-family: 'Orbitron';
            font-size: 1.35rem;
            color: var(--text-primary);
            margin-bottom: 6px;
            font-weight: 700;
        }
        .dev-role {
            font-size: 0.9rem;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 16px;
            font-weight: 600;
        }
        .dev-bio {
            font-size: 0.9rem;
            color: var(--text-dim);
            line-height: 1.7;
            text-align: right;
            margin-bottom: 18px;
        }
        .dev-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            padding-top: 18px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .dev-stat { text-align: center; }
        .dev-stat-val {
            display: block;
            font-family: 'Orbitron';
            font-size: 1.25rem;
            color: var(--accent-green);
            margin-bottom: 4px;
            font-weight: 700;
        }
        .dev-stat-label { font-size: 0.78rem; color: var(--text-dim); font-weight: 500; }

        /* Game Log */
        .game-log {
            height: 150px;
            overflow-y: auto;
            background: var(--bg-tertiary);
            border-radius: 14px;
            padding: 14px;
            font-family: 'Courier New', monospace;
            font-size: 0.82rem;
            color: var(--text-dim);
            border: var(--border-glass);
        }
        .log-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            display: flex;
            gap: 10px;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }
        .log-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .log-time { color: var(--accent-cyan); font-weight: 600; min-width: 60px; font-family: 'Orbitron'; font-size: 0.75rem; }
        .log-msg.win { color: var(--accent-green); font-weight: 600; }
        .log-msg.lose { color: var(--accent-red); font-weight: 600; }
        .log-msg.draw { color: var(--accent-gold); font-weight: 600; }
        .log-msg.ai { color: var(--accent-pink); font-weight: 600; }
        .log-msg.sys { color: var(--accent-cyan); font-style: italic; }

        /* === MAIN STAGE === */
        .main-stage {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 20px;
        }

        /* Neural Network Visualizer - FIXED & ENHANCED */
        .neural-viz {
            position: absolute;
            top: 35px;
            left: 35px;
            width: 200px;
            height: 200px;
            background: var(--bg-tertiary);
            border: var(--border-glass);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-deep), 0 0 30px rgba(0, 245, 255, 0.1);
            z-index: 15;
            backdrop-filter: blur(10px);
        }
        .neural-canvas { 
            width: 100%; 
            height: 100%; 
            display: block;
        }
        .neural-label {
            position: absolute;
            bottom: 10px;
            left: 14px;
            font-size: 0.75rem;
            color: var(--accent-cyan);
            font-family: 'Orbitron';
            text-transform: uppercase;
            letter-spacing: 1.5px;
            z-index: 2;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }
        .neural-status {
            position: absolute;
            top: 10px;
            right: 14px;
            font-size: 0.7rem;
            color: var(--accent-green);
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Orbitron';
            font-weight: 600;
        }
        .neural-status-dot {
            width: 7px; height: 7px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 1.2s infinite;
            box-shadow: 0 0 10px var(--accent-green);
        }

        /* Game Info */
        .game-info {
            text-align: center;
            margin-bottom: 40px;
            z-index: 20;
            max-width: 600px;
        }
        .status-main {
            font-family: 'Orbitron';
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 6px;
            margin-bottom: 14px;
            text-shadow: 0 0 40px rgba(255,255,255,0.5);
            transition: var(--transition-smooth);
            background: linear-gradient(90deg, var(--text-primary), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .status-main.victory {
            color: var(--accent-green);
            text-shadow: 0 0 50px var(--accent-green), 0 0 100px var(--accent-green), 0 0 150px var(--accent-green);
            animation: epicGlow 1.5s ease-in-out infinite alternate;
            -webkit-text-fill-color: var(--accent-green);
        }
        @keyframes epicGlow {
            from { text-shadow: 0 0 40px rgba(0,255,157,0.6); }
            to { text-shadow: 0 0 80px rgba(0,255,157,1), 0 0 140px rgba(0,255,157,0.8), 0 0 200px rgba(0,255,157,0.6); }
        }
        .status-sub {
            font-size: 1.2rem;
            color: var(--accent-cyan);
            min-height: 1.8em;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .ai-comment {
            font-size: 1rem;
            color: var(--accent-pink);
            margin-top: 12px;
            font-style: italic;
            min-height: 1.6em;
            animation: fadeIn 0.4s;
            font-weight: 500;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        /* Board */
        .board-container {
            position: relative;
            padding: 30px;
            background: var(--bg-tertiary);
            border-radius: 28px;
            border: var(--border-glass);
            box-shadow: var(--shadow-glow), var(--shadow-deep);
            backdrop-filter: blur(20px);
            z-index: 20;
            transition: var(--transition-smooth);
        }
        .board-container:hover {
            box-shadow: 0 0 80px rgba(0, 245, 255, 0.25), var(--shadow-deep);
            transform: translateY(-2px);
        }
        .board {
            display: grid;
            grid-template-columns: repeat(3, 140px);
            grid-template-rows: repeat(3, 140px);
            gap: 20px;
        }
        .cell {
            background: linear-gradient(145deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border-radius: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6rem;
            font-family: 'Orbitron';
            cursor: pointer;
            transition: var(--transition-bounce);
            position: relative;
            z-index: 10;
            border: 2px solid transparent;
            backdrop-filter: blur(5px);
        }
        .cell::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 22px;
            padding: 2px;
            background: linear-gradient(135deg, transparent, rgba(255,255,255,0.2), transparent);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            opacity: 0;
            transition: 0.3s;
        }
        .cell:hover {
            background: rgba(0, 245, 255, 0.15);
            transform: scale(1.08) translateY(-3px);
            border-color: rgba(0, 245, 255, 0.5);
            box-shadow: 0 0 35px rgba(0, 245, 255, 0.35);
        }
        .cell:hover::before { opacity: 1; }
        .cell.x {
            color: var(--accent-cyan);
            text-shadow: 0 0 40px var(--accent-cyan), 0 0 80px var(--accent-cyan);
            animation: popIn 0.45s forwards;
        }
        .cell.o {
            color: var(--accent-pink);
            text-shadow: 0 0 40px var(--accent-pink), 0 0 80px var(--accent-pink);
            animation: popIn 0.45s forwards;
        }
        @keyframes popIn {
            0% { transform: scale(0) rotate(-40deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        /* SVG Winning Line */
        .winning-svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        .winning-path {
            fill: none;
            stroke: var(--accent-gold);
            stroke-width: 14;
            stroke-linecap: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            filter: drop-shadow(0 0 25px var(--accent-gold));
            transition: stroke-dashoffset 1.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        /* Controls */
        .controls {
            margin-top: 50px;
            display: flex;
            gap: 24px;
            z-index: 20;
        }
        .action-btn {
            padding: 18px 48px;
            font-family: 'Orbitron';
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            background: transparent;
            border: 2px solid var(--accent-cyan);
            color: var(--accent-cyan);
            border-radius: 50px;
            cursor: pointer;
            transition: var(--transition-bounce);
            box-shadow: 0 0 25px rgba(0, 245, 255, 0.3);
            position: relative;
            overflow: hidden;
            min-width: 150px;
        }
        .action-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,245,255,0.4), transparent);
            transition: 0.6s;
        }
        .action-btn:hover::before { left: 100%; }
        .action-btn:hover {
            background: var(--accent-cyan);
            color: #000;
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.7);
            transform: translateY(-5px);
        }
        .action-btn.secondary {
            border-color: var(--accent-pink);
            color: var(--accent-pink);
            box-shadow: 0 0 25px rgba(212, 70, 255, 0.3);
        }
        .action-btn.secondary:hover {
            background: var(--accent-pink);
            color: #fff;
            box-shadow: 0 0 50px rgba(212, 70, 255, 0.7);
        }

        /* === VICTORY CELEBRATION OVERLAY === */
        .celebration-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 2000;
            display: none;
        }
        .celebration-overlay.active { display: block; }
        
        .confetti {
            position: absolute;
            width: 14px; height: 22px;
            border-radius: 3px;
            animation: confettiFall 3.5s ease-out forwards;
            opacity: 0;
        }
        @keyframes confettiFall {
            0% { transform: translateY(-120px) rotate(0deg) scale(0); opacity: 1; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg) scale(1); opacity: 0; }
        }
        
        .victory-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-family: 'Orbitron';
            font-size: 5.5rem;
            font-weight: 900;
            color: var(--accent-green);
            text-shadow: 0 0 60px var(--accent-green), 0 0 120px var(--accent-green);
            animation: victoryPop 0.9s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            white-space: nowrap;
            z-index: 2001;
            letter-spacing: 4px;
        }
        @keyframes victoryPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
            40% { transform: translate(-50%, -50%) scale(1.3) rotate(3deg); }
            70% { transform: translate(-50%, -50%) scale(0.95) rotate(-1deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0); opacity: 1; }
        }

        .screen-shake {
            animation: epicShake 0.6s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
        }
        @keyframes epicShake {
            10%, 90% { transform: translate3d(-3px, 0, 0); }
            20%, 80% { transform: translate3d(6px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-12px, 0, 0); }
            40%, 60% { transform: translate3d(12px, 0, 0); }
        }

        /* Particle Background */
        .particles {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .particle {
            position: absolute;
            width: 4px; height: 4px;
            background: var(--accent-cyan);
            border-radius: 50%;
            opacity: 0.6;
            animation: floatParticle 8s infinite;
        }
        @keyframes floatParticle {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0.6; }
            50% { transform: translateY(-30px) translateX(15px); opacity: 1; }
        }

        /* Mobile Responsive */
        @media (max-width: 1100px) {
            .sidebar {
                position: fixed;
                height: 100%;
                transform: translateX(100%);
                width: 100%;
                max-width: 440px;
            }
            .sidebar.visible { transform: translateX(0); }
            .board {
                grid-template-columns: repeat(3, 110px);
                grid-template-rows: repeat(3, 110px);
            }
            .cell { font-size: 4.5rem; }
            .neural-viz { width: 160px; height: 160px; top: 20px; left: 20px; }
            .status-main { font-size: 2.3rem; }
            .controls { flex-wrap: wrap; justify-content: center; }
            .action-btn { min-width: 130px; padding: 16px 32px; font-size: 0.9rem; }
        }

        @media (max-width: 500px) {
            .board {
                grid-template-columns: repeat(3, 90px);
                grid-template-rows: repeat(3, 90px);
                gap: 12px;
            }
            .cell { font-size: 3.5rem; border-radius: 16px; }
            .board-container { padding: 20px; }
            .status-main { font-size: 1.8rem; letter-spacing: 3px; }
            .neural-viz { width: 130px; height: 130px; }
            .theme-toggle, .sidebar-toggle { width: 48px; height: 48px; font-size: 1.3rem; }
            .theme-toggle { right: 78px; }
        }
    </style>
</head>
<body>

    <!-- === PARTICLE BACKGROUND === -->
    <div class="particles" id="particles"></div>

    <!-- === FLOATING TOGGLE BUTTON === -->
    <button class="sidebar-toggle" id="sidebarToggle" title="ÿßŸÑŸÇÿßÿ¶ŸÖÿ©">‚ò∞</button>

    <!-- === THEME TOGGLE === -->
    <button class="theme-toggle" id="themeToggle" title="ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä/ÿßŸÑŸÜŸáÿßÿ±Ÿä">üåô</button>

    <!-- === SIDEBAR === -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="logo">MENZO-XO</div>
            <button class="sidebar-close" id="closeSidebar">‚úï</button>
        </div>

        <div class="sidebar-content">
            
            <!-- Levels -->
            <div class="section">
                <div class="section-title">üéÆ ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ∞ŸÉÿßÿ°</div>
                <div class="level-grid">
                    <button class="level-btn" onclick="setLevel('easy', this)">üå± ŸÖÿ®ÿ™ÿØÿ¶</button>
                    <button class="level-btn" onclick="setLevel('medium', this)">‚öîÔ∏è ŸÖÿ≠ÿ™ÿ±ŸÅ</button>
                    <button class="level-btn" onclick="setLevel('hard', this)">üëë ÿ•ŸÑŸáŸä</button>
                    <button class="level-btn ultimate active" onclick="setLevel('ultimate', this)">‚ú® ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä - ULTIMATE</button>
                </div>
            </div>

            <!-- Cloud Learning Panel -->
            <div class="section">
                <div class="section-title">üß† ÿßŸÑÿ™ÿπŸÑŸÖ ÿßŸÑÿ≥ÿ≠ÿßÿ®Ÿä</div>
                <div class="cloud-panel">
                    <div class="cloud-header">
                        <div class="cloud-dot"></div>
                        <span style="font-weight:700;color:var(--text-primary);">Neural Sync Active</span>
                    </div>
                    <div class="cloud-stat">
                        <span>ÿ£ŸÜŸÖÿßÿ∑ ŸÖÿ≠ŸÅŸàÿ∏ÿ©:</span>
                        <span id="savedPatterns">0</span>
                    </div>
                    <div class="cloud-stat">
                        <span>ÿØŸàÿ±ÿßÿ™ ÿ™ÿπŸÑŸÖ:</span>
                        <span id="learningCycles">0</span>
                    </div>
                    <div class="cloud-stat">
                        <span>ÿØŸÇÿ© ÿßŸÑÿ™ŸÜÿ®ÿ§:</span>
                        <span id="predictionAcc">96.3%</span>
                    </div>
                    <div class="cloud-stat">
                        <span>ÿ™ŸÉŸäŸÅ ÿßŸÑŸÑÿßÿπÿ®:</span>
                        <span id="playerAdapt">ÿ™ÿ≠ŸÑŸäŸÑ...</span>
                    </div>
                    <div class="upload-bar" id="uploadBar">
                        <div class="upload-progress" id="uploadProgress"></div>
                    </div>
                </div>
            </div>

            <!-- Developer Profile -->
            <div class="section">
                <div class="section-title">üë®‚Äçüíª ÿßŸÑŸÖÿ∑Ÿàÿ±</div>
                <div class="dev-card">
                    <div class="dev-avatar">M</div>
                    <div class="dev-name">Mohamed El-Menzalawy</div>
                    <div class="dev-role">Ultimate AI Architect</div>
                    <div class="dev-bio">
                        ÿ±ÿßÿ¶ÿØ ÿπÿßŸÑŸÖŸä ŸÅŸä ÿ£ŸÜÿ∏ŸÖÿ© ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿßŸÑÿ™ŸÅÿßÿπŸÑŸäÿ©. ŸÖÿ®ÿ™ŸÉÿ± ÿÆŸàÿßÿ±ÿ≤ŸÖŸäÿ© "ÿßŸÑÿ™ÿπŸÑŸÖ ÿßŸÑÿ™ŸÉŸäŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸÖÿ±" ÿßŸÑÿ™Ÿä ÿ™ÿ¨ÿπŸÑ ÿßŸÑŸÄ AI Ÿäÿ™ÿ∑Ÿàÿ± ÿ®ŸÑÿß ÿ≠ÿØŸàÿØ ŸÖÿπ ŸÉŸÑ ÿ™ŸÅÿßÿπŸÑ.
                    </div>
                    <div class="dev-stats">
                        <div class="dev-stat">
                            <span class="dev-stat-val">v‚àû</span>
                            <span class="dev-stat-label">ÿßŸÑÿ•ÿµÿØÿßÿ±</span>
                        </div>
                        <div class="dev-stat">
                            <span class="dev-stat-val">100%</span>
                            <span class="dev-stat-label">ÿßŸÑÿπÿ®ŸÇÿ±Ÿäÿ©</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Game Log -->
            <div class="section">
                <div class="section-title">üìã ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖÿπÿ±ŸÉÿ©</div>
                <div class="game-log" id="gameLog">
                    <div class="log-entry"><span class="log-time">--:--:--</span><span class="log-msg sys">‚ú® Ultimate Singularity Initialized</span></div>
                    <div class="log-entry"><span class="log-time">--:--:--</span><span class="log-msg sys">üß† Neural Core Online</span></div>
                    <div class="log-entry"><span class="log-time">--:--:--</span><span class="log-msg sys">üë®‚Äçüíª by Mohamed El-Menzalawy</span></div>
                </div>
            </div>

        </div>
    </div>

    <!-- === MAIN STAGE === -->
    <div class="main-stage">
        
        <!-- Neural Network Visualizer - FIXED -->
        <div class="neural-viz">
            <canvas class="neural-canvas" id="neuralCanvas"></canvas>
            <div class="neural-label">AI BRAIN</div>
            <div class="neural-status">
                <div class="neural-status-dot"></div>
                <span id="neuralStatus">IDLE</span>
            </div>
        </div>

        <!-- Game Info -->
        <div class="game-info">
            <h1 class="status-main" id="statusMain">ULTIMATE</h1>
            <div class="status-sub" id="statusSub">‚ú® Self-Evolving Neural Intelligence</div>
            <div class="ai-comment" id="aiComment"></div>
        </div>

        <!-- Board -->
        <div class="board-container">
            <svg class="winning-svg">
                <path id="winPath" class="winning-path" d="" />
            </svg>
            <div class="board" id="board">
                <!-- Cells generated by JS -->
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="action-btn" onclick="getHint()">üí° ÿ™ŸÑŸÖŸäÿ≠</button>
            <button class="action-btn secondary" onclick="resetGame()">üîÑ ÿ•ÿπÿßÿØÿ©</button>
        </div>

    </div>

    <!-- Victory Celebration Overlay -->
    <div class="celebration-overlay" id="celebrationOverlay">
        <div class="victory-text">üèÜ LEGENDARY WIN! üèÜ</div>
    </div>

    <script>
        // === THEME SYSTEM ===
        const ThemeSys = {
            init() {
                const saved = localStorage.getItem('menzo_theme');
                if (saved) {
                    document.body.setAttribute('data-theme', saved);
                    this.updateIcon(saved);
                }
                document.getElementById('themeToggle').addEventListener('click', () => this.toggle());
            },
            toggle() {
                const current = document.body.getAttribute('data-theme') || 'dark';
                const next = current === 'dark' ? 'light' : 'dark';
                document.body.setAttribute('data-theme', next);
                localStorage.setItem('menzo_theme', next);
                this.updateIcon(next);
                addLog(`üé® Theme changed to ${next === 'dark' ? 'Dark' : 'Light'} Mode`, 'sys');
            },
            updateIcon(theme) {
                document.getElementById('themeToggle').innerText = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
            }
        };

        // === AUDIO SYSTEM ===
        const AudioSys = {
            ctx: null,
            enabled: true,
            comments: {
                start: ["ŸÑŸÜÿ®ÿØÿ£ Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ≠ŸÑÿ©!", "ÿ£ŸÜÿß ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿ™ÿ≠ÿØŸä ÿßŸÑÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä!", "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ≥ÿ™ÿπÿØ ŸÑŸÑŸÇŸÖÿ©?", "ÿØÿπŸÜÿß ŸÜŸÉÿ™ÿ® ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÖÿπÿßŸã!"],
                thinking: ["ÿ£ÿ≠ŸÑŸÑ 10 ŸÖŸÑÿßŸäŸäŸÜ ÿ≥ŸäŸÜÿßÿ±ŸäŸà...", "ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÉŸÖŸàŸÖŸä ÿ¨ÿßÿ±Ÿç...", "ÿ£ÿ™ŸàŸÇÿπ ÿ≠ÿ±ŸÉÿ™ŸÉ ÿßŸÑÿ™ÿßŸÑŸäÿ©...", "ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ÿßŸÑÿπÿµÿ®Ÿäÿ©..."],
                goodMove: ["ÿ≠ÿ±ŸÉÿ© ÿπÿ®ŸÇÿ±Ÿäÿ©!", "Ÿáÿ∞ÿß Ÿäÿ™ÿ≠ÿØŸâ ÿ™ŸàŸÇÿπÿßÿ™Ÿä!", "ŸÖÿ≥ÿ™ŸàÿßŸÉ ŸÖÿ∞ŸáŸÑ!", "ÿ£ÿ≠ÿ™ÿßÿ¨ ŸÑŸÑÿ™ŸÅŸÉŸäÿ± ÿ®ÿπŸÖŸÇ ÿ£ŸÉÿ´ÿ±!"],
                badMove: ["ŸÅÿ±ÿµÿ© ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ©...", "ÿ≥ÿ£ÿ≥ÿ™ÿ∫ŸÑ Ÿáÿ∞ÿß ÿ®ÿ≠ŸÉŸÖÿ©.", "ÿßŸÑŸÖŸÜÿ∑ŸÇ ŸÅŸä ÿµÿßŸÑÿ≠Ÿä.", "ÿ™ÿ≠ŸÑŸäŸÑ: Ÿáÿ∞Ÿá ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿ™ÿÆÿØŸÖ ÿÆÿ∑ÿ™Ÿä."],
                win: ["ÿßŸÑÿ≥Ÿäÿ∑ÿ±ÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©!", "ÿßŸÑŸÜÿ∏ÿßŸÖ Ÿäÿ™ŸÅŸàŸÇ ŸÉŸÖÿß ÿµŸèŸÖŸÖ.", "ŸÅŸàÿ≤ ŸÖÿ≠ÿ≥Ÿàÿ® ÿ®ÿØŸÇÿ© ÿ±Ÿäÿßÿ∂Ÿäÿ©.", "ÿßŸÑÿ∞ŸÉÿßÿ° ŸäŸÜÿ™ÿµÿ± ÿØÿßÿ¶ŸÖÿßŸã."],
                lose: ["ŸÖŸÅÿßÿ¨ÿ£ÿ© ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ¶Ÿäÿ©! ÿ≥ÿ£ÿ™ÿπŸÑŸÖ.", "ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©: ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠.", "ÿ≥ÿ£ÿπŸàÿØ ÿ®ÿ£ŸÇŸàŸâ ŸÖŸÜ ŸÇÿ®ŸÑ.", "Ÿáÿ∞ÿß Ÿäÿ¨ÿπŸÑŸÜŸä ÿ£ŸÅÿ∂ŸÑ."],
                draw: ["ÿ™ÿπÿßÿØŸÑ ŸÖŸÑÿ≠ŸÖŸä!", "ŸÇŸàÿßŸÜÿß ŸÖÿ™Ÿàÿßÿ≤ŸÜÿ© ÿ™ŸÖÿßŸÖÿßŸã.", "ÿ≥ÿ£ÿ≠ŸÑŸÑ Ÿáÿ∞ÿß ŸÑŸÑÿ™ÿ≠ÿ≥ŸÜ.", "ŸÖÿπÿ±ŸÉÿ© ÿ™ÿ≥ÿ™ÿ≠ŸÇ ÿßŸÑÿ™ÿ∞ŸÉÿ±."],
                victory: ["üèÜ ÿßŸÜÿ™ÿµÿßÿ± ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä! üèÜ", "ŸÑŸÇÿØ Ÿáÿ≤ŸÖÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ≠ŸäŸÑ!", "ÿ£ŸÜÿ™ ÿ™ÿ≥ÿ™ÿ≠ŸÇ Ÿáÿ∞ÿß ÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤!", "ÿπÿ®ŸÇÿ±Ÿäÿ© ÿ®ÿ¥ÿ±Ÿäÿ© ÿ™ŸÅŸàŸÇ ÿßŸÑÿ™ŸàŸÇÿπÿßÿ™!"]
            },

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) { console.log('Audio not supported'); }
            },

            playTone(freq, type, duration, vol = 0.08) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            playWin() {
                [523, 659, 784, 1047].forEach((f, i) => 
                    setTimeout(() => this.playTone(f, 'sine', 0.25), i * 120)
                );
            },
            playLose() { this.playTone(280, 'sawtooth', 0.5, 0.06); },
            playDraw() { 
                this.playTone(440, 'triangle', 0.3);
                setTimeout(() => this.playTone(523, 'triangle', 0.3), 250);
            },
            playThink() { this.playTone(600 + Math.random()*200, 'sine', 0.1, 0.03); },

            speak(text) {
                document.getElementById('aiComment').innerText = `"${text}"`;
            },
            getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
        };

        // === NEURAL NETWORK VISUALIZER - FIXED & ENHANCED ===
        const NeuralViz = {
            canvas: null, ctx: null, nodes: [], connections: [],
            active: false, state: 'idle', // idle, thinking, attacking, defending
            colors: { idle: '#00f5ff', thinking: '#ffd700', attacking: '#ff4d7a', defending: '#00ff9d' },
            
            init() {
                this.canvas = document.getElementById('neuralCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.createNetwork();
                this.animate();
            },

            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.offsetWidth * window.devicePixelRatio;
                this.canvas.height = container.offsetHeight * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            },

            createNetwork() {
                const count = this.active ? 45 : 28;
                const width = this.canvas.width / window.devicePixelRatio;
                const height = this.canvas.height / window.devicePixelRatio;
                
                this.nodes = [];
                for (let i = 0; i < count; i++) {
                    this.nodes.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        vx: (Math.random() - 0.5) * (this.active ? 1.8 : 0.6),
                        vy: (Math.random() - 0.5) * (this.active ? 1.8 : 0.6),
                        radius: Math.random() * 2.5 + 1.5,
                        pulse: Math.random() * Math.PI * 2,
                        color: this.colors[this.state]
                    });
                }
                
                // Create connections
                this.connections = [];
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const dx = this.nodes[i].x - this.nodes[j].x;
                        const dy = this.nodes[i].y - this.nodes[j].y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < (this.active ? 75 : 55)) {
                            this.connections.push({ a: i, b: j, strength: 1 - dist/(this.active?75:55) });
                        }
                    }
                }
            },

            setState(state) {
                this.state = state;
                this.active = state !== 'idle';
                document.getElementById('neuralStatus').innerText = state.toUpperCase();
                document.getElementById('neuralStatus').style.color = this.colors[state];
                
                // Update node colors
                this.nodes.forEach(n => n.color = this.colors[state]);
                this.createNetwork();
            },

            animate() {
                const width = this.canvas.width / window.devicePixelRatio;
                const height = this.canvas.height / window.devicePixelRatio;
                this.ctx.clearRect(0, 0, width, height);
                
                // Draw connections first (behind nodes)
                this.ctx.lineWidth = 1.2;
                this.connections.forEach(conn => {
                    const n1 = this.nodes[conn.a], n2 = this.nodes[conn.b];
                    const alpha = conn.strength * (this.active ? 0.7 : 0.35);
                    this.ctx.strokeStyle = n1.color;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.beginPath();
                    this.ctx.moveTo(n1.x, n1.y);
                    this.ctx.lineTo(n2.x, n2.y);
                    this.ctx.stroke();
                });
                
                // Draw nodes
                this.nodes.forEach(n => {
                    // Update position
                    n.x += n.vx; n.y += n.vy; n.pulse += 0.06;
                    
                    // Bounce
                    if (n.x < 0 || n.x > width) n.vx *= -1;
                    if (n.y < 0 || n.y > height) n.vy *= -1;
                    
                    // Draw with glow
                    const pulseSize = n.radius + Math.sin(n.pulse) * 0.8;
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.fillStyle = n.color;
                    
                    // Glow effect
                    const gradient = this.ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, pulseSize * 3);
                    gradient.addColorStop(0, n.color);
                    gradient.addColorStop(0.4, n.color + '80');
                    gradient.addColorStop(1, 'transparent');
                    this.ctx.fillStyle = gradient;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(n.x, n.y, pulseSize * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Core
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath();
                    this.ctx.arc(n.x, n.y, pulseSize * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                this.ctx.globalAlpha = 1;
                requestAnimationFrame(() => this.animate());
            }
        };

        // === PERSISTENT AI MEMORY ===
        const AIMemory = {
            key: 'menzo_ultimate_ai_v‚àû',
            
            get() {
                try {
                    const data = localStorage.getItem(this.key);
                    return data ? JSON.parse(data) : {
                        patterns: [], winPatterns: [], drawPatterns: [], losePatterns: [],
                        playerStyle: {}, cycles: 0, lastSync: Date.now(), accuracy: 96.3
                    };
                } catch(e) { return this.getInitial(); }
            },
            
            getInitial() {
                return { patterns: [], winPatterns: [], drawPatterns: [], losePatterns: [], playerStyle: {}, cycles: 0, lastSync: Date.now(), accuracy: 96.3 };
            },
            
            save(data) {
                data.lastSync = Date.now();
                try {
                    localStorage.setItem(this.key, JSON.stringify(data));
                    this.showSync();
                    this.updateUI();
                } catch(e) { console.log('Storage full, clearing old data'); }
            },
            
            addPattern(board, result, playerMove = null) {
                const data = this.get();
                const hash = board.join('');
                const pattern = { hash, board: [...board], result, timestamp: Date.now(), playerMove };
                
                if (!data.patterns.some(p => p.hash === hash)) {
                    data.patterns.push(pattern);
                    if (result === 'win') data.winPatterns.push(hash);
                    if (result === 'draw') data.drawPatterns.push(hash);
                    if (result === 'lose') data.losePatterns.push(hash);
                    
                    // Update player style analysis
                    if (playerMove !== null) {
                        data.playerStyle[playerMove] = (data.playerStyle[playerMove] || 0) + 1;
                    }
                    
                    data.cycles++;
                    // Improve accuracy over time
                    data.accuracy = Math.min(99.9, 94 + (data.cycles * 0.08));
                    
                    this.save(data);
                    return true;
                }
                return false;
            },
            
            getInsight(board, isAIMove = true) {
                const data = this.get();
                const hash = board.join('');
                
                // Check historical outcomes
                const history = data.patterns.filter(p => p.hash === hash);
                if (history.length > 0) {
                    const losses = history.filter(p => p.result === 'lose').length;
                    const draws = history.filter(p => p.result === 'draw').length;
                    
                    if (losses > 0 && isAIMove) return { type: 'avoid', reason: 'Led to defeat previously', confidence: losses / history.length };
                    if (draws > 0 && isAIMove) return { type: 'improve', reason: 'Previously resulted in draw', confidence: draws / history.length };
                }
                
                // Player pattern prediction
                if (!isAIMove && Object.keys(data.playerStyle).length > 5) {
                    const preferred = Object.entries(data.playerStyle).sort((a,b) => b[1] - a[1])[0];
                    if (preferred && board[preferred[0]] === null) {
                        return { type: 'predict', reason: `Player prefers position ${preferred[0]}`, confidence: preferred[1] / data.cycles };
                    }
                }
                
                return null;
            },
            
            showSync() {
                const bar = document.getElementById('uploadBar');
                const progress = document.getElementById('uploadProgress');
                bar.style.display = 'block';
                progress.style.width = '0%';
                
                setTimeout(() => progress.style.width = '35%', 120);
                setTimeout(() => progress.style.width = '75%', 350);
                setTimeout(() => {
                    progress.style.width = '100%';
                    setTimeout(() => bar.style.display = 'none', 250);
                }, 650);
            },
            
            updateUI() {
                const data = this.get();
                document.getElementById('savedPatterns').innerText = data.patterns.length;
                document.getElementById('learningCycles').innerText = data.cycles;
                document.getElementById('predictionAcc').innerText = data.accuracy.toFixed(1) + '%';
                
                // Player adaptation analysis
                const moves = Object.values(data.playerStyle);
                if (moves.length > 0) {
                    const avg = moves.reduce((a,b) => a+b, 0) / moves.length;
                    const style = avg > 3 ? 'ÿπÿØŸàÿßŸÜŸä' : avg > 1.5 ? 'ŸÖÿ™Ÿàÿßÿ≤ŸÜ' : 'ÿØŸÅÿßÿπŸä';
                    document.getElementById('playerAdapt').innerText = style;
                }
            }
        };

        // === UI FUNCTIONS ===
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const isMobile = window.innerWidth <= 1100;
            if (isMobile) sidebar.classList.toggle('visible');
            else sidebar.classList.toggle('hidden');
        }

        document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
        document.getElementById('closeSidebar').addEventListener('click', toggleSidebar);

        function addLog(msg, type = 'sys') {
            const log = document.getElementById('gameLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString('ar-EG', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-msg ${type}">${msg}</span>`;
            log.insertBefore(entry, log.firstChild);
            if (log.children.length > 35) log.removeChild(log.lastChild);
        }

        // FIXED: Pass button element directly
        function setLevel(level, btn) {
            document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            currentLevel = level;
            addLog(`üéÆ Level: ${level.toUpperCase()}`, 'sys');
            
            const statusMap = {
                easy: "üå± Casual Mode - Local Processing",
                medium: "‚öîÔ∏è Tactical Analysis Active",
                hard: "üëë Minimax God Mode",
                ultimate: "‚ú® Self-Evolving Neural Intelligence"
            };
            document.getElementById('statusSub').innerText = statusMap[level] || statusMap.ultimate;
            
            if (level === 'ultimate') {
                AudioSys.speak(AudioSys.getRandom(AudioSys.comments.start));
                AIMemory.updateUI();
            }
            resetGame();
            if (window.innerWidth <= 1100) document.getElementById('sidebar').classList.remove('visible');
        }

        // === PARTICLE BACKGROUND ===
        function initParticles() {
            const container = document.getElementById('particles');
            for (let i = 0; i < 50; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = Math.random() * 100 + '%';
                p.style.top = Math.random() * 100 + '%';
                p.style.animationDelay = Math.random() * 8 + 's';
                p.style.background = [
                    'var(--accent-cyan)', 'var(--accent-pink)', 
                    'var(--accent-gold)', 'var(--accent-green)'
                ][Math.floor(Math.random() * 4)];
                container.appendChild(p);
            }
        }

        // === GAME ENGINE ===
        const boardEl = document.getElementById('board');
        const statusMain = document.getElementById('statusMain');
        const statusSub = document.getElementById('statusSub');
        const aiComment = document.getElementById('aiComment');
        const winPath = document.getElementById('winPath');
        const celebrationOverlay = document.getElementById('celebrationOverlay');

        let board = Array(9).fill(null);
        let gameActive = true;
        let currentPlayer = 'X';
        let currentLevel = 'ultimate';
        let moveHistory = [];
        let playerSkill = 1; // Adaptive difficulty
        
        const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

        function initBoard() {
            boardEl.innerHTML = '<svg class="winning-svg"><path id="winPath" class="winning-path" d="" /></svg>';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.addEventListener('click', () => handleCellClick(i));
                boardEl.appendChild(cell);
            }
        }
        initBoard();

        // Initialize all systems
        ThemeSys.init();
        AudioSys.init();
        NeuralViz.init();
        AIMemory.updateUI();
        initParticles();

        function handleCellClick(index) {
            if (board[index] || !gameActive || currentPlayer !== 'X') return;
            AudioSys.playTone(720, 'sine', 0.09);
            makeMove(index, 'X');
            moveHistory.push({ player: 'X', index, board: [...board] });
            
            if (gameActive) {
                currentPlayer = 'O';
                statusMain.innerText = "AI THINKING";
                statusMain.classList.remove('victory');
                NeuralViz.setState('thinking');
                aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.thinking)}"`;
                
                // Simulate thinking with audio feedback
                const thinkInterval = setInterval(() => AudioSys.playThink(), 150);
                
                setTimeout(() => {
                    clearInterval(thinkInterval);
                    NeuralViz.setState('idle');
                    makeComputerMove();
                }, 600 + Math.random() * 500);
            }
        }

        function makeMove(index, player) {
            board[index] = player;
            const cell = boardEl.children[index + 1];
            cell.innerText = player;
            cell.classList.add(player.toLowerCase());
            
            const winCombo = checkWin(board, player);
            if (winCombo) endGame(player, winCombo);
            else if (!board.includes(null)) endGame('draw');
        }

        function makeComputerMove() {
            if (!gameActive) return;
            let moveIndex;
            
            if (currentLevel === 'easy') moveIndex = getRandomMove();
            else if (currentLevel === 'medium') {
                if (Math.random() < 0.3) moveIndex = getRandomMove();
                else moveIndex = getBestMove(5);
            } else if (currentLevel === 'hard') {
                moveIndex = getBestMove(9);
            } else if (currentLevel === 'ultimate') {
                moveIndex = getUltimateMove();
            }
            
            makeMove(moveIndex, 'O');
            moveHistory.push({ player: 'O', index: moveIndex, board: [...board] });
            
            if (gameActive) {
                currentPlayer = 'X';
                statusMain.innerText = "YOUR TURN";
                
                // Comment on player's last move
                const lastPlayerMove = [...moveHistory].reverse().find(m => m.player === 'X');
                if (lastPlayerMove && isStrategicMove(board, lastPlayerMove.index, 'X')) {
                    aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.goodMove)}"`;
                    playerSkill = Math.min(10, playerSkill + 0.3); // Player is good, adapt
                } else {
                    aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.badMove)}"`;
                    playerSkill = Math.max(1, playerSkill - 0.1);
                }
            }
        }

        // === ULTIMATE AI ALGORITHMS ===
        function getRandomMove() {
            const available = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
            return available[Math.floor(Math.random() * available.length)];
        }

        function getBestMove(depth) {
            let bestScore = -Infinity, move = -1;
            let alpha = -Infinity, beta = Infinity;
            
            for (let i = 0; i < 9; i++) {
                if (board[i] === null) {
                    board[i] = 'O';
                    const score = minimax(board, 0, false, alpha, beta, depth);
                    board[i] = null;
                    if (score > bestScore) { bestScore = score; move = i; }
                    alpha = Math.max(alpha, score);
                    if (beta <= alpha) break;
                }
            }
            return move;
        }

        function minimax(board, depth, isMaximizing, alpha, beta, depthLimit) {
            if (checkWin(board, 'O')) return 10 - depth;
            if (checkWin(board, 'X')) return depth - 10;
            if (!board.includes(null)) return 0;
            if (depth >= depthLimit) return evaluateBoard(board);
            
            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === null) {
                        board[i] = 'O';
                        const score = minimax(board, depth + 1, false, alpha, beta, depthLimit);
                        board[i] = null;
                        bestScore = Math.max(score, bestScore);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break;
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === null) {
                        board[i] = 'X';
                        const score = minimax(board, depth + 1, true, alpha, beta, depthLimit);
                        board[i] = null;
                        bestScore = Math.min(score, bestScore);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break;
                    }
                }
                return bestScore;
            }
        }

        // Enhanced board evaluation for better mid-game play
        function evaluateBoard(boardState) {
            let score = 0;
            // Center control
            if (boardState[4] === 'O') score += 3;
            if (boardState[4] === 'X') score -= 3;
            // Corner control
            [0,2,6,8].forEach(i => {
                if (boardState[i] === 'O') score += 1;
                if (boardState[i] === 'X') score -= 1;
            });
            // Threat detection
            wins.forEach(combo => {
                const values = combo.map(i => boardState[i]);
                const oCount = values.filter(v => v === 'O').length;
                const xCount = values.filter(v => v === 'X').length;
                if (oCount === 2 && xCount === 0) score += 5;
                if (xCount === 2 && oCount === 0) score -= 5;
            });
            return score;
        }

        // ULTIMATE LEVEL: Hybrid AI with learning and prediction
        function getUltimateMove() {
            // Monte Carlo style simulation: try multiple random continuations
            const simulations = 15;
            const moveScores = {};
            
            const available = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
            
            available.forEach(move => {
                let totalScore = 0;
                for (let s = 0; s < simulations; s++) {
                    const simBoard = [...board];
                    simBoard[move] = 'O';
                    totalScore += simulateGame(simBoard, 'X');
                }
                moveScores[move] = totalScore / simulations;
            });
            
            // Get best move from simulations
            let bestMove = available[0], bestScore = -Infinity;
            for (const [move, score] of Object.entries(moveScores)) {
                if (score > bestScore) { bestScore = score; bestMove = parseInt(move); }
            }
            
            // Apply memory insights
            if (currentLevel === 'ultimate') {
                const testBoard = [...board];
                testBoard[bestMove] = 'O';
                const insight = AIMemory.getInsight(testBoard, true);
                
                if (insight && insight.confidence > 0.4) {
                    addLog(`üß† AI Insight: ${insight.reason} (${(insight.confidence*100).toFixed(0)}%)`, 'ai');
                    if (insight.type === 'avoid') {
                        // Find alternative
                        const alt = available.find(m => {
                            const tb = [...board]; tb[m] = 'O';
                            return !AIMemory.getInsight(tb, true);
                        });
                        if (alt !== undefined) return alt;
                    }
                }
                
                // Player prediction
                const playerInsight = AIMemory.getInsight(board, false);
                if (playerInsight && playerInsight.type === 'predict') {
                    NeuralViz.setState('attacking');
                    addLog(`üéØ Predicting player move: ${playerInsight.reason}`, 'ai');
                }
            }
            
            return bestMove;
        }

        // Monte Carlo simulation for move evaluation
        function simulateGame(boardState, currentPlayer) {
            let simBoard = [...boardState];
            let simPlayer = currentPlayer;
            
            for (let depth = 0; depth < 8; depth++) {
                const available = simBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
                if (available.length === 0) break;
                
                // Random but weighted move selection
                const move = available[Math.floor(Math.random() * available.length)];
                simBoard[move] = simPlayer;
                
                if (checkWin(simBoard, simPlayer)) {
                    return simPlayer === 'O' ? 10 : -10;
                }
                simPlayer = simPlayer === 'O' ? 'X' : 'O';
            }
            return evaluateBoard(simBoard) * 0.1; // Small weight for unfinished games
        }

        function checkWin(boardState, player) {
            return wins.some(combo => combo.every(i => boardState[i] === player));
        }

        function isStrategicMove(boardState, index, player) {
            const testBoard = [...boardState];
            testBoard[index] = player;
            for (const combo of wins) {
                const count = combo.filter(i => testBoard[i] === player).length;
                if (count === 2 && combo.includes(index)) return true;
            }
            return [4].includes(index) && boardState.filter(v => v !== null).length < 4;
        }

        function endGame(winner, combo = null) {
            gameActive = false;
            NeuralViz.setState('idle');
            let result, logType;
            
            if (winner === 'draw') {
                result = 'draw'; logType = 'draw';
                statusMain.innerText = "EPIC DRAW";
                aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.draw)}"`;
                AudioSys.playDraw();
                addLog('ü§ù Epic draw achieved', 'draw');
                if (currentLevel === 'ultimate') AIMemory.addPattern([...board], 'draw');
                
            } else {
                if (winner === 'X') {
                    result = 'lose'; logType = 'win';
                    statusMain.innerText = "LEGENDARY WIN!";
                    statusMain.classList.add('victory');
                    aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.victory)}"`;
                    AudioSys.playWin();
                    triggerVictoryCelebration();
                    addLog('üèÜ Player achieved LEGENDARY victory!', 'win');
                    playerSkill = Math.min(10, playerSkill + 0.5);
                    if (currentLevel === 'ultimate') AIMemory.addPattern([...board], 'lose', moveHistory.filter(m => m.player === 'X').pop()?.index);
                    
                } else {
                    result = 'win'; logType = 'lose';
                    statusMain.innerText = "AI VICTORY";
                    statusMain.classList.remove('victory');
                    aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.win)}"`;
                    AudioSys.playLose();
                    addLog('ü§ñ AI secured victory', 'lose');
                    playerSkill = Math.max(1, playerSkill - 0.2);
                    if (currentLevel === 'ultimate') AIMemory.addPattern([...board], 'win');
                }
                if (combo) drawWinLine(combo);
            }
            
            AIMemory.updateUI();
        }

        function drawWinLine(combo) {
            const cell1 = boardEl.children[combo[0] + 1];
            const cell3 = boardEl.children[combo[2] + 1];
            const boardRect = boardEl.getBoundingClientRect();
            const r1 = cell1.getBoundingClientRect();
            const r3 = cell3.getBoundingClientRect();
            
            const x1 = r1.left + r1.width/2 - boardRect.left;
            const y1 = r1.top + r1.height/2 - boardRect.top;
            const x2 = r3.left + r3.width/2 - boardRect.left;
            const y2 = r3.top + r3.height/2 - boardRect.top;
            
            const path = document.getElementById('winPath');
            path.setAttribute('d', `M ${x1} ${y1} L ${x2} ${y2}`);
            setTimeout(() => path.style.strokeDashoffset = '0', 120);
        }

        // === EPIC VICTORY CELEBRATION ===
        function triggerVictoryCelebration() {
            const overlay = celebrationOverlay;
            overlay.classList.add('active');
            document.querySelector('.main-stage').classList.add('screen-shake');
            setTimeout(() => document.querySelector('.main-stage').classList.remove('screen-shake'), 600);
            
            const colors = [
                'var(--accent-cyan)', 'var(--accent-pink)', 
                'var(--accent-gold)', 'var(--accent-green)', '#ffffff'
            ];
            
            for (let i = 0; i < 120; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.width = (8 + Math.random() * 12) + 'px';
                    confetti.style.height = (14 + Math.random() * 18) + 'px';
                    confetti.style.animationDuration = (2.5 + Math.random() * 2) + 's';
                    confetti.style.animationDelay = Math.random() * 0.8 + 's';
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '3px';
                    overlay.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 25);
            }
            setTimeout(() => overlay.classList.remove('active'), 4500);
        }

        // === UTILITIES ===
        function getHint() {
            if (!gameActive || currentPlayer !== 'X') return;
            let bestScore = -Infinity, bestMove = -1;
            for (let i = 0; i < 9; i++) {
                if (board[i] === null) {
                    board[i] = 'X';
                    const score = minimax(board, 0, false, -Infinity, Infinity, 6);
                    board[i] = null;
                    if (score > bestScore) { bestScore = score; bestMove = i; }
                }
            }
            if (bestMove !== -1) {
                const cell = boardEl.children[bestMove + 1];
                cell.style.boxShadow = `inset 0 0 40px var(--accent-gold), 0 0 30px var(--accent-gold)`;
                cell.style.borderColor = 'var(--accent-gold)';
                setTimeout(() => { cell.style.boxShadow = ''; cell.style.borderColor = ''; }, 2800);
                statusSub.innerText = `üí° Ultimate Hint: Position ${bestMove}`;
                addLog(`üí° Hint: Optimal move at ${bestMove}`, 'sys');
            }
        }

        function resetGame() {
            board = Array(9).fill(null);
            gameActive = true;
            currentPlayer = 'X';
            moveHistory = [];
            statusMain.innerText = "ULTIMATE";
            statusMain.classList.remove('victory');
            statusSub.innerText = currentLevel === 'ultimate' ? 
                "‚ú® Self-Evolving Neural Intelligence" : "Processing...";
            aiComment.innerText = '';
            document.getElementById('winPath').style.strokeDashoffset = '1000';
            
            document.querySelectorAll('.cell').forEach(cell => {
                cell.innerText = '';
                cell.classList.remove('x', 'o');
                cell.style.boxShadow = '';
                cell.style.borderColor = '';
            });
            addLog('üîÑ New ultimate match initialized', 'sys');
            
            if (currentLevel === 'ultimate' && Math.random() > 0.6) {
                setTimeout(() => aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.start)}"`, 400);
            }
        }

        // Initial greeting
        setTimeout(() => {
            addLog('‚ú® MENZO-XO Ultimate Singularity Ready', 'sys');
            addLog('üë®‚Äçüíª Engineered by Mohamed El-Menzalawy', 'sys');
            if (currentLevel === 'ultimate') {
                aiComment.innerText = `"${AudioSys.getRandom(AudioSys.comments.start)}"`;
            }
        }, 800);

    </script>
</body>
    </html>
